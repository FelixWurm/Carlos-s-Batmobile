<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>MSE workaround vanilla</title>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
        }

        .mse-video-size {
            max-width: 50%;
            display: block;
            margin: 0 auto;
        }

        .flex-center {
            display: flex;
            justify-content: center;
        }
    </style>
</head>
<body>
    <video id="livestream" class="mse-video-size" autoplay muted></video>
    <br>
    <div class="flex-center">
        <a href="#" id="left">&#8592;</a>
        <p id="current-channel"></p>
        <a href="#" id="right">&#8594;</a>
    </div>
    <script>
        let streamStarted = false;
        let reload = false;
        let sourceBuffer, streamQueue = [];
        let ws;

        function initialize() {
            let load = document.getElementById('livestream');
            if ('MediaSource' in window) {
                let isPlaying = true;
                let ms = new MediaSource();
                ms.addEventListener('sourceopen', start(ms), false);
                load.src = window.URL.createObjectURL(ms);
                load.onpause = () => {
                    stop()
                };
                load.onplay = () => {
                    if (isPlaying === false) {
                        start(ms);
                    }
                };
            } else {
                console.error('Unsupported: MSE')
            }
        }

        // Start job with WebSocket
        function start(ms) {
            let load = document.getElementById('livestream')
            /* Just an example how to prepare link for WS */
            const schema = 'ws'
            const server = 'localhost'
            const port = '8083'
            const uuid = '27aec28e-6181-4753-9acd-0456a75f0289'
            const maxChannel = 10;

            let channel;

            if (window.location.hash) {
                channel = window.location.hash.replace(/\D/g, '');
            } else {
                channel = 0;
            }

            reload = false;

            // Set channel switch button
            window.document.getElementById("left").href = "#" + Math.max(0, channel - 1);
            window.document.getElementById("right").href = "#" + Math.min(maxChannel, channel - (-1));
            window.document.getElementById("current-channel").innerText = "Current channel: " + channel;

            let url = schema + '://' + server + ':' + port + '/stream/' + uuid + '/channel/' + channel + '/mse?uuid=' + uuid + '&channel=' + channel;
            ws = new WebSocket(url)
            ws.binaryType = 'arraybuffer'

            addEventListener('hashchange', function (event) {
                reload = true;
                sourceBuffer = undefined;
                ws.close(3000, 'hash url change');
            });

            ws.onopen = function () {
                console.log("Connections has been established");
            };

            ws.onclose = function (event) {
                if (event.wasClean) {
                    console.log('Connection closed successfully');
                } else {
                    console.log('Connection has been terminated');
                }
                console.log('Code: ' + event.code + ' reason: ' + event.reason);
            };

            ws.onmessage = function (event) {
                console.log("Got packet for decoding");
                const data = new Uint8Array(event.data)
                if (data[0] === 9) {
                    // Decond on initialization
                    const decodedArr = data.slice(1)
                    let mimeCodec
                    if (window.TextDecoder) {
                        mimeCodec = new TextDecoder('utf-8').decode(decodedArr)
                    } else {
                        mimeCodec = String.fromCharCode(decodedArr)
                    }
                    console.log("Codec:", mimeCodec);
                    if (!sourceBuffer && load) {
                        sourceBuffer = ms.addSourceBuffer('video/mp4; codecs="' + mimeCodec + '"')
                        sourceBuffer.mode = 'segments'
                        sourceBuffer.addEventListener('updateend', loadPacket())
                    }
                } else {
                    /* Write to buffer */
                    pushPacket(event.data)
                }
            };
            ws.onerror = function (error) {
                console.log("Error:", error.message);
                if(reload) {
                    console.log("Reload stream");
                    initialize();
                }
            };
        }

        function pushPacket(data) {
            let load = document.getElementById('livestream');
            if (!streamStarted && load) {
                sourceBuffer.appendBuffer(data);
                streamStarted = true;
                return;
            }
            streamQueue.push(data);
            if (!sourceBuffer.updating) {
                loadPacket();
            }
        }

        function loadPacket() {
            let load = document.getElementById('livestream')
            if (!sourceBuffer.updating && load) {
                if (streamQueue.length > 0) {
                    const inp = streamQueue.shift()
                    sourceBuffer.appendBuffer(inp)
                } else {
                    streamStarted = false
                }
            }
        }

        initialize();

    </script>

</body>
</html>
